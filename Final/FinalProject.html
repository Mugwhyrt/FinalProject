<!DOCTYPE html>
<html>
	<head>
		<meta charset = "utf-8">
		<title> Final Project </title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; heigh: 100% }
		</style>
	</head>
	<body>
		<script src = "../three.js-master/build/three.js"></script>
		<script src = "building.js"></script>
                <script src ="CameraControls.js"></script>
		<script>
                    // Turn off default arrow key functions
                    // to prevent window from scrolling
                    // when user applies camera rotation
                    window.addEventListener("keydown", function(e) {
                    // space and arrow keys
                    if([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
                     e.preventDefault();
                       }
                    }, false);
                    
                     // Initialize Camera Movement Vars
                    //
                    // boolean values for whether to apply a given
                    // transformation to the camera
                    var moveForward = false;
                    var moveBackward = false;
                    var moveLeft = false;
                    var moveRight = false;
                    var moveUp = false;
                    var moveDown = false;

                    var rotateLeft = false;
                    var rotateRight = false;
                    var rotateUp = false;
                    var rotateDown = false;

                    var moveRate = 0.085;
                    var turnRate = 0.035
                    
                     // Initialize Perspective Camera
                    // (FOV, Aspect Ratio, Near Clipping Plane, 
                    //  Far Clipping Plane)
                    var camera = 
                        new THREE.PerspectiveCamera(75, 
                                                    window.innerWidth / 
                                                    window.innerHeight,
                                                    0.1,
                                                    1000);
                    //var collisions = [];
                    function main(){
                    //
                    // Initialize Scene With Camera
                    //
                    var scene = new THREE.Scene();
                   
                    //camera.position.z = 5;
                    camera.rotation.y = -Math.PI/2;
                    
                    // Set camera rotation order to Yaw/Pitch/Roll
                    camera.rotation.order = 'YXZ';
                    
                    var renderer = new THREE.WebGLRenderer();
                    renderer.setSize( window.innerWidth, window.innerHeight );
                    document.body.appendChild(renderer.domElement);
                    
                    document.addEventListener('keydown', onKeyDown, false);
                    document.addEventListener('keyup', onKeyUp, false);
                    
                    
                    // Add lights
                    var point = new THREE.PointLight(0xffffff, 2, 100);
                    point.position.set(4, 4, 2);
                    scene.add(point);
                    point = new THREE.PointLight(0xffffff, 1, 100);
                    point.position.set(-4, 3, 2);
                    scene.add(point);
                    
                    var ambient = new THREE.AmbientLight(0x505050);
                    scene.add(ambient);
                    // Initialise Building Materials
                    var windowMaterial = new THREE.MeshPhongMaterial({color: 0x1044ff});
                    var walls = new THREE.MeshPhongMaterial({color: 0xffaa33});
                    var material = new THREE.MeshPhongMaterial( { color: 0x00ff00 } );

                    var loader = new THREE.TextureLoader();
		    var wallMaterial = new THREE.MeshPhongMaterial({
                                            map : loader.load('albedo.jpg'),
                                            bumpMap : loader.load('bump.jpg'),
                                            bumpScale : 0.005,
                                            shininess : 10,
                                            specularMap : loader.load('specular.jpg')});
                    const streetMaterial = new THREE.MeshPhongMaterial({color:0x505050});
                                            
                    const city = new THREE.Object3D;
                    var buildingBase = [10,10];
                    // street dimensions, [length, width]
                    var streetDims = [100, 5];
                    // get first street and add to city
                    var street = getStreet(streetDims, buildingBase, streetMaterial,
                                        wallMaterial, windowMaterial);
                    city.add(street);
                    // get second street, rotate, and add to city
                    streetDims = [200, 5];
                    street = getStreet(streetDims, buildingBase, streetMaterial,
                                        wallMaterial, windowMaterial);
                    street.rotation.y = Math.PI/4;
                    city.add(street);
                    
                    // For each street in city
                    for(var this_s = 0; this_s < city.children.length;
                        this_s++){
                        // set streetOne to the current street object
                        streetOne = city.children[this_s];
                        // get bounding box of the road on the street one
                        s_boxOne = new THREE.Box3().setFromObject(streetOne.children[0]);
                        // apply streetOne's world matrix to s_boxOne
                        s_boxOne.applyMatrix4(streetOne.matrixWorld);
                        scene.add(new THREE.Box3Helper(s_boxOne, 0xff00ff));
                        // For each street after this_s, get bounding boxes and
                        // match transformations to object's transforms
                        for(var that_s = this_s + 1; that_s < city.children.length;
                                that_s++){
                            streetTwo = city.children[that_s];
                            s_boxTwo = new THREE.Box3().setFromObject(streetTwo.children[0]);
                            console.log(streetTwo.matrixWorld);
                            s_boxTwo.applyMatrix4(streetTwo.matrixWorld);
                            scene.add(new THREE.Box3Helper(s_boxTwo, 0x00ff00));
                            // check for intersections between buildings
                        } // end that_s loop
                    } // end this_s loop
                    
                    scene.add(city);
                    
                    //building.children[0].geometry.computeBoundingBox();
                    //var collider  = new THREE.Box3();
                    //collider.setFromObject(building);
                    //collisions.push(collider);
                      
                    function animate(){
                        requestAnimationFrame( animate );
                       
                        // Apply camera transformations based on
                        // keyboard input (including projection changes), 
                        // check collisions and boundary
                        // and undo transformations if neccessary
                        // All 3 functions found in CameraControls
                        applyCameraTransforms(camera);   
                        //checkCameraCollision(collisions);
                        
                        renderer.render(scene, camera );
                    }
                    // animate on canvas
                    animate();
                    }
                    main();
		</script>
	</body>
</html>